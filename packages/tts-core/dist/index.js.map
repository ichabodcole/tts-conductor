{"version":3,"sources":["../src/config.ts","../src/utils/chunker.ts","../src/utils/debug.ts","../src/utils/duration.ts","../src/utils/pause.ts","../src/utils/segmenter.ts","../src/utils/stitcher.ts","../src/operations.ts","../src/conductor.ts","../src/defaults.ts"],"sourcesContent":["export enum ProcessStage {\n  /** Individual audio chunks from providers */\n  Raw = 'raw',\n  /** Final assembled audio after stitching */\n  Final = 'final',\n  /** Fallback stage when not specified by caller */\n  Unknown = 'unknown',\n}\n\nexport interface TtsLogger {\n  debug?: (...args: unknown[]) => void;\n  info?: (...args: unknown[]) => void;\n  warn?: (...args: unknown[]) => void;\n  error?: (...args: unknown[]) => void;\n}\n\nexport interface DebugMeta {\n  fileName: string; // Always provided by core package\n  jobId?: string; // Optional, provided by consuming projects\n  stage: ProcessStage | string; // Always provided by core package\n  [key: string]: unknown; // Allow arbitrary additional metadata\n}\n\nexport interface DebugSink {\n  saveBuffer?: (buffer: Buffer, meta: DebugMeta) => Promise<void> | void;\n  saveFile?: (path: string, meta: DebugMeta) => Promise<void> | void;\n}\n\nexport interface FfmpegConfig {\n  ffmpegPath?: string;\n  ffprobePath?: string;\n}\n\nexport interface TtsRuntimeConfig {\n  /** Map of pause labels (e.g. FULL_BREATH) to seconds */\n  pauses: Record<string, number>;\n  logger?: TtsLogger;\n  debug?: DebugSink;\n  ffmpeg?: FfmpegConfig;\n}\n\nexport interface BuildAudioOptions {\n  debugJobId?: string;\n}\n","import type { ProviderCapabilities } from '../provider';\nimport type { TtsLogger } from '../config';\nimport type { Segment } from './segmenter';\n\nexport interface Chunk {\n  ssml: string;\n  postPause: number;\n}\n\nfunction splitByBoundaries(input: string, maxLen: number): string[] {\n  const chunks: string[] = [];\n  let text = input;\n  const hardMax = Math.max(1, maxLen);\n\n  const isInsideTag = (str: string, pos: number): boolean => {\n    const lastLt = str.lastIndexOf('<', pos);\n    const lastGt = str.lastIndexOf('>', pos);\n    return lastLt > lastGt;\n  };\n\n  const adjustPosToAvoidTags = (str: string, pos: number): number => {\n    if (!isInsideTag(str, pos)) return pos;\n    const lt = str.lastIndexOf('<', pos);\n    let p = lt > 0 ? lt - 1 : pos;\n    while (p > 0 && !/\\s/.test(str.charAt(p))) p--;\n    return Math.max(1, p);\n  };\n\n  while (text.length > hardMax) {\n    const window = text.slice(0, hardMax);\n\n    let splitPos = window.lastIndexOf('\\n\\n');\n    if (splitPos < 0) splitPos = window.lastIndexOf('\\n');\n    if (splitPos < 0) {\n      const sentenceRe = /[.!?](?=\\s|$)/g;\n      let lastEnd = -1;\n      let m: RegExpExecArray | null;\n      while ((m = sentenceRe.exec(window))) {\n        lastEnd = m.index + 1;\n      }\n      if (lastEnd >= 0) splitPos = lastEnd;\n    }\n    if (splitPos < 0) splitPos = window.lastIndexOf(' ');\n    if (splitPos < 0) splitPos = hardMax;\n\n    splitPos = adjustPosToAvoidTags(window, splitPos);\n\n    const head = text.slice(0, splitPos).trimEnd();\n    chunks.push(head);\n    text = text.slice(splitPos).trimStart();\n  }\n\n  if (text) chunks.push(text);\n  return chunks;\n}\n\nexport function toChunks(\n  segments: Segment[],\n  caps: ProviderCapabilities,\n  logger?: TtsLogger,\n): Chunk[] {\n  const INLINE_LIMIT = caps.maxInlineBreakSeconds ?? 0;\n  const renderInlineBreak =\n    caps.renderInlineBreak ?? ((seconds: number) => `<break time=\"${seconds}s\" />`);\n  const MAX_CHARS =\n    typeof caps.maxCharsPerRequest === 'number' && isFinite(caps.maxCharsPerRequest)\n      ? Math.max(1, caps.maxCharsPerRequest - 16)\n      : undefined;\n\n  const chunks: Chunk[] = [];\n  let buffer = '';\n  let postPause = 0;\n\n  const flush = () => {\n    if (buffer) {\n      chunks.push({ ssml: buffer.trim(), postPause });\n      buffer = '';\n      postPause = 0;\n    }\n  };\n\n  for (const seg of segments) {\n    if (seg.kind === 'text') {\n      const next = (buffer ? buffer + ' ' : '') + seg.value;\n      if (MAX_CHARS && next.length > MAX_CHARS) {\n        const parts = splitByBoundaries(next, MAX_CHARS);\n        for (let i = 0; i < parts.length - 1; i++) {\n          const part = (parts[i] ?? '').trim();\n          if (part) {\n            chunks.push({ ssml: part, postPause: 0 });\n          }\n        }\n        const tail = parts.length > 0 ? parts[parts.length - 1] : '';\n        buffer = tail ? tail : '';\n        postPause = 0;\n      } else {\n        buffer = next;\n      }\n    } else {\n      if (INLINE_LIMIT && seg.seconds <= INLINE_LIMIT) {\n        const inlineBreak = renderInlineBreak(seg.seconds);\n        buffer += ` ${inlineBreak}`;\n      } else {\n        postPause = seg.seconds;\n        flush();\n      }\n    }\n  }\n\n  flush();\n  logger?.debug?.('[tts] toChunks result', chunks);\n  return chunks;\n}\n","import type { DebugMeta, TtsRuntimeConfig } from '../config';\nimport { ProcessStage } from '../config';\n\nexport interface DebugOptions {\n  fileName?: string;\n  jobId?: string;\n  stage?: DebugMeta['stage'];\n}\n\nfunction buildMeta(options: DebugOptions): DebugMeta {\n  return {\n    fileName: options.fileName ?? `tts_${Date.now()}.mp3`,\n    jobId: options.jobId,\n    stage: options.stage ?? ProcessStage.Unknown, // Provide default if not specified\n  };\n}\n\nexport async function saveDebugFromBuffer(\n  config: TtsRuntimeConfig,\n  buffer: Buffer,\n  options: DebugOptions = {},\n): Promise<void> {\n  const sink = config.debug;\n  if (!sink?.saveBuffer) return;\n  const meta = buildMeta(options);\n  await sink.saveBuffer(buffer, meta);\n}\n\nexport async function saveDebugFromFile(\n  config: TtsRuntimeConfig,\n  path: string,\n  options: DebugOptions = {},\n): Promise<void> {\n  const sink = config.debug;\n  if (!sink?.saveFile) return;\n  const meta = buildMeta(options);\n  await sink.saveFile(path, meta);\n}\n","import { execa } from 'execa';\nimport ffmpegPath from 'ffmpeg-static';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport { tmpdir } from 'os';\nimport type { FfmpegConfig } from '../config';\nimport type { TtsLogger } from '../config';\n\nasync function resolveFfprobeBin(ffmpegConfig?: FfmpegConfig): Promise<string> {\n  const candidates = [ffmpegConfig?.ffprobePath, process.env.FFPROBE_PATH, 'ffprobe'].filter(\n    Boolean,\n  ) as string[];\n\n  for (const candidate of candidates) {\n    try {\n      await fs.access(candidate);\n      return candidate;\n    } catch {\n      // continue searching\n    }\n  }\n  return candidates[candidates.length - 1] ?? 'ffprobe';\n}\n\nasync function resolveFfmpegBin(ffmpegConfig?: FfmpegConfig): Promise<string> {\n  const candidates = [\n    ffmpegConfig?.ffmpegPath,\n    process.env.FFMPEG_PATH,\n    process.env.FFMPEG_BIN,\n  ].filter(Boolean) as string[];\n\n  for (const candidate of candidates) {\n    try {\n      await fs.access(candidate);\n      return candidate;\n    } catch {\n      // continue searching\n    }\n  }\n\n  if (ffmpegPath) {\n    try {\n      await fs.access(ffmpegPath);\n      return ffmpegPath;\n    } catch {\n      // fall through to default\n    }\n  }\n\n  return 'ffmpeg';\n}\n\nexport async function getAudioDuration(\n  audioBuffer: Buffer,\n  ffmpegConfig?: FfmpegConfig,\n  logger?: TtsLogger,\n): Promise<number> {\n  const tempFile = path.join(tmpdir(), `tts_conductor_temp_${Date.now()}.mp3`);\n\n  try {\n    await fs.writeFile(tempFile, audioBuffer);\n\n    const ffprobeBin = await resolveFfprobeBin(ffmpegConfig);\n    const ffprobeResult = await execa(\n      ffprobeBin,\n      [\n        '-v',\n        'error',\n        '-show_entries',\n        'format=duration',\n        '-of',\n        'default=noprint_wrappers=1:nokey=1',\n        tempFile,\n      ],\n      { reject: false },\n    );\n    const probeOut = ffprobeResult.stdout?.toString().trim() ?? '';\n    const parsedProbe = parseFloat(probeOut);\n    if (!Number.isNaN(parsedProbe) && parsedProbe > 0) {\n      return Math.round(parsedProbe * 100) / 100;\n    }\n\n    const ffmpegBin = await resolveFfmpegBin(ffmpegConfig);\n    const ffmpegResult = await execa(ffmpegBin, ['-i', tempFile], { reject: false });\n    const stderr = ffmpegResult.stderr?.toString() ?? '';\n    const match = stderr.match(/Duration:\\s*(\\d+):(\\d+):(\\d+(?:\\.\\d+)?)/);\n    if (match) {\n      const hours = parseInt(match[1] ?? '0', 10);\n      const minutes = parseInt(match[2] ?? '0', 10);\n      const seconds = parseFloat(match[3] ?? '0');\n      const total = hours * 3600 + minutes * 60 + seconds;\n      return Math.round(total * 100) / 100;\n    }\n  } catch (error) {\n    logger?.warn?.('Failed to read accurate audio duration, falling back to estimation', error);\n  } finally {\n    try {\n      await fs.unlink(tempFile);\n    } catch {\n      // ignore cleanup errors\n    }\n  }\n\n  return estimateAudioDuration(audioBuffer);\n}\n\nexport function estimateAudioDuration(audioBuffer: Buffer, bitrate = 128): number {\n  return Math.round(((audioBuffer.length * 8) / (bitrate * 1000)) * 100) / 100;\n}\n","export type PauseTable = Record<string, number>;\n\nfunction lookup(table: PauseTable, label: string): number {\n  return table[label.toUpperCase()] ?? 0;\n}\n\n/**\n * Parse pause duration from various pause formats\n * Supports patterns like:\n *   [PAUSE:LABEL]\n *   [PAUSE:LABEL:Nx]\n *   [PAUSE:LABEL:Ns]\n *   [PAUSE:Ns]\n */\nexport function parsePauseDuration(pauseMatch: string, table: PauseTable): number {\n  const content = pauseMatch.replace(/^\\[PAUSE:/, '').replace(/\\]$/, '');\n\n  const numericMatch = content.match(/^(\\d+(?:\\.\\d+)?)s?$/i);\n  if (numericMatch) {\n    return parseFloat(numericMatch[1] ?? '0');\n  }\n\n  const modifierMatch = content.match(/^([A-Z_]+):(\\d+(?:\\.\\d+)?)([xs])$/i);\n  if (modifierMatch) {\n    const [, rawLabel, rawValue, suffix] = modifierMatch;\n    const label = rawLabel?.toUpperCase() ?? '';\n    const numValue = rawValue ? parseFloat(rawValue) : 0;\n    const base = lookup(table, label);\n    if (suffix?.toLowerCase() === 'x') {\n      return base * numValue;\n    }\n    if (suffix?.toLowerCase() === 's') {\n      return numValue;\n    }\n  }\n\n  const legacyMatch = content.match(/^(BREATH|FULL_BREATH|HALF_BREATH):(\\d+)$/i);\n  if (legacyMatch) {\n    const [, rawLabel, rawMultiplier] = legacyMatch;\n    const base = lookup(table, rawLabel?.toUpperCase() ?? '');\n    return base * (rawMultiplier ? parseInt(rawMultiplier, 10) : 0);\n  }\n\n  return lookup(table, content.toUpperCase());\n}\n\nexport function isValidPauseFormat(input: string): boolean {\n  return /^\\[PAUSE:([A-Z_]+(?::\\d+(?:\\.\\d+)?[xs]?)?|\\d+(?:\\.\\d+)?s?)\\]$/i.test(input);\n}\n\nexport function extractPauseMarkers(text: string): string[] {\n  const matches = text.match(/\\[PAUSE:([A-Z_]+(?::\\d+(?:\\.\\d+)?[xs]?)?|\\d+(?:\\.\\d+)?s?)\\]/gi);\n  return matches ?? [];\n}\n","import type { TtsLogger } from '../config';\nimport { parsePauseDuration } from './pause';\nimport type { PauseTable } from './pause';\n\nexport type Segment =\n  | { kind: 'text'; value: string }\n  | { kind: 'pause'; label: string; seconds: number };\n\nconst PAUSE_RE = /\\[PAUSE:([A-Z_]+(?::\\d+(?:\\.\\d+)?[xs]?)?|\\d+(?:\\.\\d+)?s?)\\]/gi;\n\nexport function parseScript(input: string, table: PauseTable, logger?: TtsLogger): Segment[] {\n  PAUSE_RE.lastIndex = 0;\n  const segments: Segment[] = [];\n  let lastIndex = 0;\n  let match: RegExpExecArray | null;\n\n  while ((match = PAUSE_RE.exec(input))) {\n    if (match.index > lastIndex) {\n      const textContent = input.slice(lastIndex, match.index).trim();\n      if (textContent) {\n        segments.push({ kind: 'text', value: textContent });\n      }\n    }\n\n    const fullMatch = match[0] ?? '';\n    const label = match[1] ?? '';\n    const seconds = parsePauseDuration(fullMatch, table);\n\n    if (!label) {\n      logger?.warn?.('Invalid pause format encountered', { fullMatch });\n    } else {\n      segments.push({ kind: 'pause', label, seconds });\n    }\n\n    lastIndex = PAUSE_RE.lastIndex;\n  }\n\n  if (lastIndex < input.length) {\n    const textContent = input.slice(lastIndex).trim();\n    if (textContent) {\n      segments.push({ kind: 'text', value: textContent });\n    }\n  }\n\n  for (let i = 1; i < segments.length - 1; i++) {\n    const prev = segments[i - 1];\n    const current = segments[i];\n    const next = segments[i + 1];\n    if (current.kind !== 'pause' || prev.kind !== 'text' || next.kind !== 'text') continue;\n\n    const dashTail = prev.value.match(/[-\\u2013\\u2014]\\s*$/u);\n    if (dashTail) {\n      prev.value = prev.value.replace(/[-\\u2013\\u2014]\\s*$/u, '').replace(/\\s+$/u, '');\n      const cleaned = next.value.replace(/^\\s+/u, '');\n      const dashChar = dashTail[0]?.trim() || '—';\n      next.value = `${dashChar} ${cleaned}`;\n    }\n\n    const punctuationMatch = next.value.match(/^(\\s*)([.,!?:;…\"')\\]]+)/);\n    if (punctuationMatch) {\n      const punct = punctuationMatch[2] ?? '';\n      if (punct) {\n        prev.value = prev.value.replace(/\\s+$/u, '') + punct;\n        next.value = next.value.slice((punctuationMatch[0] ?? '').length).replace(/^\\s+/u, '');\n      }\n    }\n  }\n\n  logger?.debug?.('[tts] parseScript output', segments);\n  return segments;\n}\n","import { execa } from 'execa';\nimport fs from 'fs/promises';\nimport { tmpdir } from 'os';\nimport path from 'path';\nimport type { BuildAudioOptions, FfmpegConfig, TtsLogger, TtsRuntimeConfig } from '../config';\nimport { ProcessStage } from '../config';\nimport type { Chunk } from './chunker';\nimport { saveDebugFromFile } from './debug';\n\ninterface AudioPart {\n  buffer: Buffer;\n  duration: number;\n}\n\nconst silenceCache = new Map<number, string>();\nconst MAX_SILENCE_CACHE_SIZE = 50;\n\nasync function resolveFfmpegBin(ffmpegConfig?: FfmpegConfig): Promise<string> {\n  const candidates = [\n    ffmpegConfig?.ffmpegPath,\n    process.env.FFMPEG_PATH,\n    process.env.FFMPEG_BIN,\n  ].filter(Boolean) as string[];\n\n  for (const candidate of candidates) {\n    try {\n      await fs.access(candidate);\n      return candidate;\n    } catch {\n      // continue search\n    }\n  }\n\n  const ffmpegStatic = (await import('ffmpeg-static')).default;\n  if (ffmpegStatic) {\n    try {\n      await fs.access(ffmpegStatic);\n      return ffmpegStatic;\n    } catch {\n      // fall through\n    }\n  }\n\n  return 'ffmpeg';\n}\n\nasync function genSilenceWav(seconds: number, ffmpegConfig?: FfmpegConfig, logger?: TtsLogger) {\n  if (silenceCache.has(seconds)) return silenceCache.get(seconds)!;\n\n  const out = path.join(tmpdir(), `tts_conductor_silence_${seconds}.wav`);\n  const ffmpegBin = await resolveFfmpegBin(ffmpegConfig);\n\n  try {\n    await execa(\n      ffmpegBin,\n      [\n        '-f',\n        'lavfi',\n        '-i',\n        `anullsrc=r=44100:cl=mono`,\n        '-t',\n        seconds.toString(),\n        '-ac',\n        '1',\n        '-ar',\n        '44100',\n        '-c:a',\n        'pcm_s16le',\n        '-y',\n        out,\n      ],\n      { timeout: 30000 },\n    );\n  } catch (error) {\n    logger?.error?.('Failed to generate silence segment', { seconds, error });\n    try {\n      await fs.unlink(out);\n    } catch {\n      // ignore cleanup\n    }\n    throw error;\n  }\n\n  if (silenceCache.size >= MAX_SILENCE_CACHE_SIZE) {\n    const oldestKey = silenceCache.keys().next().value as number | undefined;\n    if (typeof oldestKey === 'number') {\n      const oldestFile = silenceCache.get(oldestKey);\n      silenceCache.delete(oldestKey);\n      if (oldestFile) {\n        fs.unlink(oldestFile).catch(() => undefined);\n      }\n    }\n  }\n\n  silenceCache.set(seconds, out);\n  return out;\n}\n\nasync function concatParts(\n  fileList: string[],\n  outPath: string,\n  ffmpegConfig?: FfmpegConfig,\n  logger?: TtsLogger,\n) {\n  const listFile = path.join(tmpdir(), `tts_conductor_concat_${Date.now()}.txt`);\n\n  try {\n    await fs.writeFile(\n      listFile,\n      fileList.map((f) => `file '${f.replace(/'/g, \"'\\\\''\")}'`).join('\\n'),\n    );\n\n    const ffmpegBin = await resolveFfmpegBin(ffmpegConfig);\n\n    try {\n      await execa(\n        ffmpegBin,\n        [\n          '-f',\n          'concat',\n          '-safe',\n          '0',\n          '-i',\n          listFile,\n          '-c:a',\n          'pcm_s16le',\n          '-ar',\n          '44100',\n          '-ac',\n          '1',\n          '-y',\n          outPath,\n        ],\n        { timeout: 45000 },\n      );\n      return;\n    } catch (error) {\n      logger?.warn?.('Concat demuxer failed, attempting filter fallback', error);\n      const args: string[] = [];\n      for (const file of fileList) {\n        args.push('-i', file);\n      }\n      const n = fileList.length;\n      const filter = `${Array.from({ length: n }, (_, i) => `[${i}:a]`).join('')}concat=n=${n}:v=0:a=1, aformat=sample_fmts=s16:sample_rates=44100:channel_layouts=mono [a]`;\n      args.push(\n        '-filter_complex',\n        filter,\n        '-map',\n        '[a]',\n        '-c:a',\n        'pcm_s16le',\n        '-ar',\n        '44100',\n        '-ac',\n        '1',\n        '-y',\n        outPath,\n      );\n      await execa(ffmpegBin, args, { timeout: 60000 });\n    }\n  } finally {\n    try {\n      await fs.unlink(listFile);\n    } catch {\n      logger?.debug?.('Failed to cleanup concat list file', { listFile });\n    }\n  }\n}\n\nexport interface BuildFinalAudioResult {\n  base64Data: string;\n  mimeType: string;\n  size: number;\n  duration: number;\n}\n\nexport async function buildFinalAudio(\n  config: TtsRuntimeConfig,\n  chunks: Chunk[],\n  audio: AudioPart[],\n  fileName = `tts_${Date.now()}.mp3`,\n  options?: BuildAudioOptions,\n): Promise<BuildFinalAudioResult> {\n  if (chunks.length !== audio.length) {\n    throw new Error('chunks and audio arrays must be equal length');\n  }\n\n  const logger = config.logger;\n  const ffmpegConfig = config.ffmpeg;\n  const tmp = tmpdir();\n  const partFiles: string[] = [];\n  const tempFilesToCleanup: string[] = [];\n\n  try {\n    const ffmpegBin = await resolveFfmpegBin(ffmpegConfig);\n    for (let i = 0; i < audio.length; i++) {\n      const speechMp3 = path.join(tmp, `tts_chunk_${i}_${Date.now()}.mp3`);\n      const speechWav = path.join(tmp, `tts_chunk_${i}_${Date.now()}.wav`);\n\n      await fs.writeFile(speechMp3, audio[i]?.buffer ?? Buffer.alloc(0));\n      tempFilesToCleanup.push(speechMp3);\n\n      await execa(\n        ffmpegBin,\n        ['-i', speechMp3, '-ar', '44100', '-ac', '1', '-c:a', 'pcm_s16le', '-y', speechWav],\n        { timeout: 30000 },\n      );\n\n      partFiles.push(speechWav);\n      tempFilesToCleanup.push(speechWav);\n\n      const chunk = chunks[i];\n      const pauseSeconds = chunk?.postPause ?? 0;\n      if (pauseSeconds > 0) {\n        const silenceFile = await genSilenceWav(pauseSeconds, ffmpegConfig, logger);\n        partFiles.push(silenceFile);\n      }\n    }\n\n    const outWavPath = path.join(tmp, `tts_concat_${Date.now()}.wav`);\n    tempFilesToCleanup.push(outWavPath);\n    await concatParts(partFiles, outWavPath, ffmpegConfig, logger);\n\n    const outPath = path.join(tmp, fileName);\n    tempFilesToCleanup.push(outPath);\n\n    await execa(\n      ffmpegBin,\n      ['-i', outWavPath, '-c:a', 'libmp3lame', '-ar', '44100', '-b:a', '192k', '-y', outPath],\n      { timeout: 45000 },\n    );\n\n    await saveDebugFromFile(config, outPath, {\n      fileName: `final_${fileName}`,\n      jobId: options?.debugJobId,\n      stage: ProcessStage.Final,\n    });\n\n    const buf = await fs.readFile(outPath);\n    const durationSec = audio.reduce((sum, part, idx) => {\n      const chunk = chunks[idx];\n      const pause = chunk?.postPause ?? 0;\n      return sum + part.duration + pause;\n    }, 0);\n\n    const result: BuildFinalAudioResult = {\n      base64Data: buf.toString('base64'),\n      mimeType: 'audio/mpeg',\n      size: buf.length,\n      duration: durationSec,\n    };\n\n    await cleanupTempFiles(tempFilesToCleanup);\n    return result;\n  } catch (error) {\n    await cleanupTempFiles(tempFilesToCleanup);\n    throw error;\n  }\n}\n\nasync function cleanupTempFiles(filePaths: string[]): Promise<void> {\n  await Promise.allSettled(\n    filePaths.map(async (filePath) => {\n      try {\n        await fs.unlink(filePath);\n      } catch {\n        // ignore\n      }\n    }),\n  );\n}\n","import type { BuildAudioOptions, TtsRuntimeConfig } from './config';\nimport { ProcessStage } from './config';\nimport type { TtsProvider } from './provider';\nimport type { Chunk } from './utils/chunker';\nimport { toChunks } from './utils/chunker';\nimport { saveDebugFromBuffer } from './utils/debug';\nimport { getAudioDuration } from './utils/duration';\nimport { parseScript } from './utils/segmenter';\nimport type { BuildFinalAudioResult } from './utils/stitcher';\nimport { buildFinalAudio } from './utils/stitcher';\n\nexport function withTimeout<T>(promise: Promise<T>, ms: number, label: string): Promise<T> {\n  let timer: NodeJS.Timeout;\n  const timeoutPromise = new Promise<T>((_, reject) => {\n    timer = setTimeout(() => {\n      reject(new Error(`[tts] Timeout after ${ms}ms during ${label}`));\n    }, ms);\n  });\n\n  return Promise.race([promise, timeoutPromise]).finally(() => {\n    clearTimeout(timer);\n  });\n}\n\nexport async function ttsGenerateFull(\n  rawText: string,\n  provider: TtsProvider,\n  config: TtsRuntimeConfig,\n  onProgress?: (percent: number) => void,\n  options?: BuildAudioOptions,\n): Promise<BuildFinalAudioResult> {\n  const logger = config.logger;\n  const providerId = provider.id;\n\n  const segments = parseScript(rawText, config.pauses, logger);\n  logger?.info?.('[tts] Parsed segments', { count: segments.length });\n\n  const chunks = toChunks(segments, provider.caps, logger);\n  logger?.info?.('[tts] Generated chunks', { count: chunks.length });\n\n  const audioParts: { buffer: Buffer; duration: number }[] = [];\n  let done = 0;\n\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i] as Chunk;\n    const input = `<speak>${chunk.ssml}</speak>`;\n    logger?.debug?.('[tts] Generating chunk', {\n      provider: providerId,\n      index: i,\n      postPause: chunk.postPause,\n    });\n\n    onProgress?.(Math.min(10, Math.round(((i + 1) / chunks.length) * 10)));\n\n    const res = await withTimeout(provider.generate(input), 60000, `provider.generate chunk ${i}`);\n\n    // Trust provider duration if supplied, otherwise compute it:\n    const duration = res.duration ?? (await getAudioDuration(res.audio, config.ffmpeg, logger));\n\n    audioParts.push({ buffer: res.audio, duration });\n    done++;\n\n    await saveDebugFromBuffer(config, res.audio, {\n      fileName: `raw_${providerId}_${i}_${Date.now()}.mp3`,\n      jobId: options?.debugJobId,\n      stage: ProcessStage.Raw,\n    });\n\n    const chunkProgress = Math.round((done / chunks.length) * 80);\n    onProgress?.(chunkProgress);\n  }\n\n  onProgress?.(80);\n  const final = await withTimeout(\n    buildFinalAudio(config, chunks, audioParts, undefined, options),\n    45000,\n    'stitcher.buildFinalAudio',\n  );\n  onProgress?.(100);\n\n  return final;\n}\n","import type { BuildAudioOptions, TtsRuntimeConfig } from './config';\nimport type {\n  ProviderOptionsFor,\n  RegisteredProviderIds,\n  TtsProviderContext,\n  TtsProviderFactory,\n} from './factory';\nimport { ttsGenerateFull } from './operations';\nimport type { TtsProvider } from './provider';\n\n// Use a more flexible approach - store the factory with minimal typing\ninterface StoredFactory {\n  id: string;\n  create: (ctx: TtsProviderContext, options: object) => TtsProvider;\n}\n\nexport class TtsConductor {\n  private providers = new Map<string, StoredFactory>();\n\n  constructor(private readonly config: TtsRuntimeConfig) {}\n\n  get runtimeConfig(): TtsRuntimeConfig {\n    return this.config;\n  }\n\n  /**\n   * Register a provider factory with type-safe options.\n   * Provider must be registered in the TtsProviderRegistry via module augmentation.\n   */\n  registerProvider<T extends RegisteredProviderIds>(factory: TtsProviderFactory<T>): T {\n    this.providers.set(factory.id, {\n      id: factory.id,\n      create: factory.create as (ctx: TtsProviderContext, options: object) => TtsProvider,\n    });\n    this.config.logger?.debug?.('Registered provider', factory.id);\n    return factory.id;\n  }\n\n  hasProvider(id: string): boolean {\n    return this.providers.has(id);\n  }\n\n  listProviders(): string[] {\n    return Array.from(this.providers.keys());\n  }\n\n  /**\n   * Create a provider instance with type-safe options.\n   * Provider must be registered in the TtsProviderRegistry via module augmentation.\n   */\n  createProvider<T extends RegisteredProviderIds>(\n    id: T,\n    options: ProviderOptionsFor<T>,\n  ): TtsProvider {\n    const factory = this.providers.get(id);\n    if (!factory) {\n      throw new Error(`Provider '${id}' is not registered`);\n    }\n    this.config.logger?.info?.('Creating provider instance', id, { options });\n    return factory.create({ config: this.config, id: factory.id }, options);\n  }\n\n  async generateFull(\n    rawText: string,\n    provider: TtsProvider,\n    onProgress?: (percent: number) => void,\n    options?: BuildAudioOptions,\n  ) {\n    return ttsGenerateFull(rawText, provider, this.config, onProgress, options);\n  }\n}\n\nexport function createTtsConductor(config: TtsRuntimeConfig): TtsConductor {\n  return new TtsConductor(config);\n}\n","import type { PauseTable } from './utils/pause';\n\nexport const DEFAULT_PAUSE_TABLE: PauseTable = {\n  MICRO: 0.5,\n  SHORT: 1.5,\n  MEDIUM: 3.5,\n  LONG: 8,\n  FULL_BREATH: 5,\n  HALF_BREATH: 3,\n  SETTLE: 10,\n  BREATH: 5,\n};\n"],"mappings":"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","names":["ProcessStage","path","execa","fs","tmpdir","path","resolveFfmpegBin","fs","path","tmpdir","execa"]}